
General implementation remarks:
-------------------------------

We designed our library using the MVC pattern.
This pattern allows good separation of responsibilities, and low coupling.

Model
------

Our model is the game board, and the model class implements some basic operations on the board.
The model holds a delegated observable object to allow the views an event based access to the board.
The observer pattern is push based - The views update only upon board change, except for the initializing stage 
when the views ask the model for the initial board state (this allows for future implementation of saved games).
We wanted to use our model with the logging proxy. This required that the model implements an interface, and references to the model
throughout the code will be via the interface type.
We have two reasons for using the delegated observable:
1. To avoid type safety issues - Since we reference the model with its interface type in our code,
   We risk getting a non-observable model (if someone else used our IModel interface without extending Observable).
   To solve this problem we added the GetObservable method to our interface and used the delegated observable, instead of extending Observable.
2. When sending our observable object to the observers, we didn't want to send the entire model for security issues, instead we send
   only the delegated Observable object, and the board array itself.

View
-----
As usually used in MVC, the view implements the observer interface - observing the model.
The view also uses a composite design pattern, to allow for future graphic UI.
In addition, we used a variation of abstract factory and flyweight for memory optimization (further details ahead).
The basic view components are the View class containing the root to the composite graphic object, IGameGraphic interface, and the CompositeGraphic abstract class.


Controller
-----------
We used an abstract controller class which implements most of the game logic.
A Client who wants to use our controller should extend it with a concrete class implementing the mainMenu method.
In our abstract class we call the client's mainMenu implementation in a loop to allow him to perform as many operations as he wants until he is ready to start the game.
Within the main menu the client can perform different operations on the view and choose different game types.
Our abstract controller also uses a player class which is used purely for our convenience of player abstraction.
The controller is instantiated with a model (the abstract controller has a protected constructor which must be called from any extending class), and can have views added and removed.


Default Implementation
-----------------------
Our default implementation is actually a sample of how our library should be used.
The client's job is basically to implement his graphics and playing strategies, 
Create a view and model instances, And then use a controller instance (which includes his implementation for the main menu)
to setup the game.

Exceptions
-----------
We mainly used exceptions so our library will be relatively foolproof, but only implemented a basic Exception structure (since it is less important for the exercise and its requirements).


Dynamic Proxy
--------------
As stated above, our dynamic proxy is set on the model and outputs to a file called model.log in the following format:
Method call: MethodName (Type1, Type2, ...)
argument details:
1. arg1
2. arg2
...

AspectJ
--------
AspectJ was also used for logging as required.
Our aspect is responsible for logging the game progress and turn times.
Note that we measured turn times based on how much time it takes the player to complete a valid turn.

Unit tests
-----------
A unit test was created for every class in our library (not including the default implementation classes).
The default implementation is more of an example code to show how a client might use the library, and therefore was not unit tested.
We achieved a high statement cover percentage.
 

How we met the requirements?

1.	As stated above, we laid down the infrastructure for clients to use the composite pattern.
	This pattern is ideal for future implementation of GUI.
	In addition, the MVC pattern enables using views dynamically, and in particular using multiple views simultaneously, changing the views dynamically, adding/removing views and more.
	Note that the game can also be ran without views at all, emphasizing the low coupling of our code.
	Some examples of adding/removing views are given in our default implementation.

2.	We implemented this requirement by simple use of the strategy pattern. The client simply implements our PlayerStrategy Interface with his own strategy.
	makeMove is the strategy method, the method receives a model instance and can decide based on the board which move to make.
	The client's new strategy can then be used in the game by sending it to our abstract controller addPlayer method.
	This might be implemented by the client's controller instance, as part of his main menu (just as our implementation MyController does).

3.  We decided to implement this requirement by "hijacking" the composite pattern and using it as decorator.
	Since these patterns are quite similar in structure, it is not a big stretch - CompositeGraphic objects can be easily used as concrete decorators (They have an array of other graphic objects with the same basic interface).
	This mechanism can be used to add graphic elements to each object.
	In practice, we helped the client even more and implemented a "decorate" method in our View class for easy decoration, while maintaining the Composite hierarchy
	This method receives three arguments:
	* father - The father of the object being decorated. If decorating root, father should be null, otherwise, will add the decorator and remove decoratee from children
	* decorator - The decorator object, wrapping the decorated object. 
	* decoratee - The decorated object, wrapped by the decorator.
	An example for using this can be seen in our default implementation.
	Another good example would be to add another view and then decorate the disc. You can see that the disc is only decorated in one of the views.

4. This was the most difficult requirement to implement correctly and make it work with our MVC pattern.
   We implemented a flyweight pattern for the discs - since all discs with the same graphics are basically the same object, we divided them to "player 1" and "player 2" discs (each with different graphic).
   This pattern fits specifically for discs because disc objects can be shared between multiple instances since they are leaves in the composite hierarchy.
   BoardGraphic however, can't be used with flyweight, since boards are composite objects, and even boards with the same underlying graphic may contain different children (such as discs).
   To make the flyweight work smoothly with the other requirements, we used a variation of abstract factory.
   The reason is that while we want to save memory on disc graphics, we also want to allow different disc graphics to be implemented for our game, and the abstract factory fits this purpose.
   The abstract factory is a singleton shared among all using instances, and supplies them with concrete factories.
   Each of these concrete factories supplies discs according to the user's request.
   Instead of asking the client to implement concrete factories himself, we implemented a "pool" (HashMap) of factories.
   The client can get a factory for his disc implementation simply by asking our abstract factory for it. Note that this requires the client to implement hashCode and equals for his disc graphic objects.
   The abstract factory receives the disc graphic implementation as an argument from the client, and checks if a factory already exists for this implementation in its pool (We assume a disc1 implementation corresponds to a single disc2 implementation, i.e. they always come in pairs).
   If a factory exists, we return it, otherwise, we create a new one for the given implementation.
   Note that GameGraphic implements Clonable interface, which is important specifically for DiscGraphics, so we can use cloned discs as HashMap keys (we don't want risking the key changing during the game, so we use a local clone in the map).
   Also note that we partially support flyweight decoration of discs - a client can get a factory for his disc decorator object,
   but he is limited in that he can only use this decorator for one disc implementation (i.e. he can't use the same decorator for two different
   disc implementations, since one will override the other in our map). In fact, the client can use our abstract factory to use any type of graphic as flyweight with this limitation in mind.
	

We would like to add that we learned a lot from this exercise, and enjoyed working on it.
